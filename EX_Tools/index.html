<!doctype html>
<!-- build: 2025-10-29-1450 stlViewer theme refresh -->
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CoMotion</title>
<style>
  :root {
    --bg: #0a0a0a;
    --panel: rgba(18, 18, 20, 0.9);
    --text: #ffffff;
    --muted: #9ca3af;
    --accent: #ffcc00;
  }
  #title {
    font-size: 15px;
    font-weight: 700;
    color: var(--accent);
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,"PingFang SC","Microsoft Yahei",Segoe UI,Roboto,Helvetica,Arial}
  #app{
  position:fixed;
  inset:0;
  display:grid;
  grid-template-columns:380px 1fr;
  grid-template-rows:100%;
  }
  /* å°å±ï¼ˆä¾‹å¦‚ <=768pxï¼‰ä¸‹ï¼Œæ”¹æˆä¸Šä¸‹å †å ï¼šå·¦è¾¹é¢æ¿å ä¸ŠåŠï¼Œç”»å¸ƒå ä¸‹åŠ */
  @media(max-width:768px){
  #app{
  grid-template-columns:100%;
  grid-template-rows:auto 1fr;
  }
  #left{
  max-height:40vh;
  border-bottom:1px solid rgba(255,255,255,0.1);
  }
  }
  #left{background:var(--panel);backdrop-filter:blur(6px);padding:10px 10px 14px;overflow:auto}
  #titlebar{display:flex;align-items:center;justify-content:space-between;margin-bottom:6px}
  #helpBtn {
  background: transparent;
  border: 1px solid rgba(255,255,255,0.15);
  color: var(--text);
  border-radius: 10px;
  padding: 6px 10px;
  cursor: pointer;
  font-size: 13px;
  line-height: 1.2;
  }
  #helpBtn:hover {
  background: rgba(255,255,255,0.06);
  }
  .muted{color:var(--muted);font-size:12px}
  .row{margin-top:8px}
  input,
  select,
  button {
  background: #1c1d20;
  border: 1px solid rgba(255,255,255,0.08);
  color: var(--text);
  border-radius: 10px;
  padding: 6px 8px;
  font-size: 13px;
  line-height: 1.2;
  }
  
  input::placeholder {
  color: var(--muted);
  opacity: .7;
  font-size: 12px;
  }
  .navBtn {
  text-decoration: none;
  background: transparent;
  border: 1px solid rgba(255,255,255,0.15);
  color: var(--text);
  border-radius: 10px;
  padding: 6px 10px;
  font-size: 13px;
  line-height: 1.2;
  display: inline-block;
  }
  .navBtn:hover {
  background: rgba(255,255,255,0.06);
  }  
  button.primary {
  background: var(--accent);
  color: #000;
  font-weight: 600;
  border: 0;
  box-shadow: 0 10px 24px rgba(255,204,0,0.4);
  }
  button.primary:hover {
  box-shadow: 0 14px 32px rgba(255,204,0,0.5);
  }
  input[type="color"]{padding:0;width:30px;height:24px;border-radius:6px}
  input[type="range"] {
  width: 100%;
  height: 4px;
  appearance: none;
  margin: 0;
  padding: 0;
  }
  button{cursor:pointer}
  #canvas{width:100%;height:100%;display:block}
  .hr{height:1px;background:#2a2f35;margin:10px 0}
  /* ç´§å‡‘éƒ¨ä»¶å¡ç‰‡ï¼šå‡å°å†…è¾¹è·ã€å­—ä½“ã€æ§ä»¶é—´è· */
  .part{display:grid;grid-template-columns:auto 1fr;gap:6px;align-items:center;margin-top:6px;padding:6px;border:1px solid #2a2f35;border-radius:10px}
  .name{font-weight:600;font-size:13px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .line{display:flex;align-items:center;gap:6px;margin-top:4px}
  .line select{height:28px;padding:2px 6px}
  .line button{height:28px;padding:2px 8px}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:6px}
  .container {
      display: flex;
      align-items: left;
	  gap: 30px;
  }
  .color-container {
      display: flex;
      align-items: center;
  }
  .fit {
      margin-left: auto;
      padding: 4px 8px;
      background: #2a2f35;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
  }  
  label{display:flex;align-items:center;gap:8px}

  /* å¸®åŠ©æ¨¡æ€æ•´ä½“æ ·å¼ */
  #help {
    display: none;               /* é»˜è®¤éšè—ï¼Œç‚¹å‡»æŒ‰é’®å†æ˜¾ç¤º */
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5); /* åŠé€æ˜é®ç½© */
    z-index: 1000;
    justify-content: center;
    align-items: center;
  }

  /* å†…å®¹æ¡† */
  #help .box {
    background: #fff;
    color: #333;
    max-width: 480px;
    padding: 20px 28px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    text-align: left;
    overflow-y: auto;
    line-height: 1.6;
  }

  /* æ ‡é¢˜ä¸æ®µè½ */
  #help h3 {
    margin-top: 0;
    color: #222;
    font-size: 1.2em;
    border-bottom: 2px solid #eee;
    padding-bottom: 8px;
  }
  #help p {
    margin: 10px 0;
    white-space: normal;
  }

  /* å…³é—­æŒ‰é’® */
  #help .close {
    text-align: right;
    margin-top: 16px;
  }
  #help .close button {
    padding: 6px 12px;
    background: #0078d7;
    color: #fff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }
  #help .close button:hover {
    background: #005ea0;
  }
  
  /* å³ä¸‹è§’ 12 é¢éª°å­ç”»å¸ƒ */
  #diceCanvas{
    position: fixed;
    right: 12px;
    bottom: 12px;
    width: 120px;   /* æƒ³æ›´å¤§/æ›´å°æ”¹è¿™é‡Œ */
    height: 120px;
    pointer-events: auto;
    background: rgba(0,0,0,0.08);
    border: 1px solid rgba(255,255,255,0.18);
    border-radius: 12px;
    box-shadow: 0 6px 18px rgba(0,0,0,.2) inset, 0 2px 6px rgba(0,0,0,.2);
  }
</style>
</head>
<body>

<div id="app">
  <div id="left">
    <div id="titlebar">
      <div id="title">CoMotion</div>
      <div style="display:flex;gap:6px">
        <a href="/" id="homeBtn" class="navBtn">è¿”å›é¦–é¡µ</a>
        <button id="helpBtn">å¸®åŠ©</button>
      </div>
    </div>
    <div class="muted">è¾“å…¥å¯†é’¥ï¼ŒåŠ è½½å¯¹åº”æ¨¡å‹ã€‚</div>

    <!-- å­æ–‡ä»¶å¤¹é€‰æ‹©ï¼šåªæœ‰è¾“å…¥ä¸ assets/<name>/manifest.json åŒ¹é…æ—¶æ‰åŠ è½½ -->
    <div class="row">
      <label style="justify-content:space-between;gap:10px">
        <span>å¯†é’¥</span>
        <input id="folderKey" value="Demo" placeholder="è¯·è¾“å…¥é¡¹ç›®åç§°" style="flex:1" />
        <button id="btnLoadFolder" class="primary">åŠ è½½</button>
      </label>
    </div>
    <div class="row grid2">
      <label><input type="checkbox" id="autoFit" checked> è‡ªåŠ¨é€‚é…</label>
      <label><input type="checkbox" id="showAxes" checked> è½´å‘è¾…åŠ©</label>
    </div>
    <div class="row grid2">
      <button id="btnFit">é€‚é…å¯è§</button>
      <button id="btnShot">æˆªå›¾PNG</button>
    </div>
    <div class="row">
      <label>äº®åº¦è°ƒæ•´
        <input type="range" id="lightIntensity" min="0" max="10" step="0.01" value="0.9">
      </label>
    </div>
    <div class="hr"></div>
    <div id="parts"></div>
  </div>
  <canvas id="canvas"></canvas>
</div>

<!-- ç®€æ˜“å¸®åŠ©æ¨¡æ€ -->
<div id="help">
  <div class="box">
    <h3>ä½¿ç”¨è¯´æ˜</h3>
    <p>è¿™ç›®å‰çŠ¶æ€è¿˜åªæ˜¯ä¸€ä¸ªç®€æ˜“çš„ä¸‰ç»´æ¨¡å‹æŸ¥çœ‹å™¨ã€‚ä½¿ç”¨æ­¥éª¤å¦‚ä¸‹ï¼š</p>
    <p>1ï¸âƒ£ åœ¨å·¦ä¸Šè§’çš„è¾“å…¥æ¡†ä¸­å¡«å…¥æ‚¨è·å¾—çš„è®¿é—®å¯†é’¥ï¼ˆå¦‚ <code>case01</code>ï¼‰ã€‚</p>
    <p>2ï¸âƒ£ ç‚¹å‡»â€œåŠ è½½â€æŒ‰é’®åï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è½½å…¥å¯¹åº”é¡¹ç›®çš„ä¸‰ç»´æ¨¡å‹ã€‚</p>
    <p>3ï¸âƒ£ æ¨¡å‹åŠ è½½å®Œæˆåï¼Œå¯é€šè¿‡å·¦ä¾§åˆ—è¡¨æ§åˆ¶æ¯ä¸ªéƒ¨ä»¶çš„æ˜¾éšã€é¢œè‰²ã€é€æ˜åº¦å’Œæ¸²æŸ“é£æ ¼ã€‚</p>
    <p>4ï¸âƒ£ å¯ä½¿ç”¨é¼ æ ‡æ—‹è½¬ã€ç¼©æ”¾ã€å¹³ç§»æ¨¡å‹ï¼›ä¹Ÿå¯ç‚¹å‡»â€œå‰è§†â€â€œé¡¶è§†â€â€œç­‰è½´æµ‹â€ç­‰å›ºå®šè§†è§’ã€‚</p>
    <p>5ï¸âƒ£ è‹¥éœ€è¦æˆªå›¾ï¼Œå¯ç‚¹å‡»â€œæˆªå›¾ PNGâ€ã€‚</p>
    <p>âš™ï¸ å¦‚æ¨¡å‹æœªæ˜¾ç¤ºï¼Œè¯·ç¡®è®¤è¾“å…¥çš„å¯†é’¥ä¸æœåŠ¡å™¨ä¸Šå¯¹åº”æ–‡ä»¶å¤¹åç§°ä¸€è‡´ã€‚</p>
    <div class="close"><button id="helpClose">å…³é—­</button></div>
  </div>
</div>

<script type="importmap">
{
  "imports": { "three": "./libs/three.module.js" }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from './libs/OrbitControls.js';
import { ArcballControls } from './controls/ArcballControls.js';
import { STLLoader }     from './libs/STLLoader.js';
import { RoomEnvironment } from './libs/RoomEnvironment.js';
import { GLTFLoader } from './libs/GLTFLoader.js';
import { ConvexGeometry } from './libs/ConvexGeometry.js';

// --------- åŸºæœ¬åœºæ™¯ï¼ˆæ­£äº¤ç›¸æœºï¼‰ ---------
const canvas   = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, preserveDrawingBuffer:true });
const w = window.innerWidth-320, h = window.innerHeight; const aspect=w/h; const base=1;
const camera = new THREE.OrthographicCamera(-base*aspect, base*aspect, base, -base, -1e6, 1e6);
function getCanvasSize() {
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width));
    const h = Math.max(1, Math.floor(rect.height));
    return { w, h };
}
camera.position.set(2,2,2); 
function resizeMainRenderer() {
    const { w, h } = getCanvasSize();
    renderer.setSize(w, h, false);

    const aspect = w / h;
    const half = 1; // åˆå§‹ç›’å­ï¼Œåé¢fitOrthoToVisibleä¼šæ ¹æ®å®é™…æ¨¡å‹å†ç»†è°ƒ
    camera.left   = -half * aspect;
    camera.right  =  half * aspect;
    camera.top    =  half;
    camera.bottom = -half;
    camera.updateProjectionMatrix();
}


renderer.setPixelRatio(window.devicePixelRatio || 1);
resizeMainRenderer();

renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.physicallyCorrectLights = true;

const scene  = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);

const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;

// const controls = new OrbitControls(camera, renderer.domElement);
// const controls = new ArcballControls(camera, renderer.domElement, scene);
// controls.enableAnimations = true;     // è½»å¾®åŠ¨ç”»è¿‡æ¸¡ï¼Œæ‰‹æ„Ÿæ›´é¡º
// controls.dampingFactor    = 0.10;     // é˜»å°¼
// controls.setGizmosVisible(false);     // ä¸è¦å³ä¸‹è§’å†…ç½®æ‰‹æŸ„

let controls;
function reinitControls() {
    if (controls && controls.dispose) {
        controls.dispose();
    }

    // æ³¨æ„ï¼šArcballControls çš„ç¬¬ä¸‰ä¸ªå‚æ•°ä½ ä¹‹å‰ä¼  sceneï¼Œæœ‰çš„å®ç°éœ€è¦ scene æ¥ç”»å°gizmo
    // å¦‚æœä½ çš„ ArcballControls æ„é€ ç­¾åä¸åŒï¼Œè¯·ä¿æŒè·Ÿä½ åŸå…ˆæ–‡ä»¶ä¸€è‡´çš„å‚æ•°é¡ºåº
    controls = new ArcballControls(camera, renderer.domElement, scene);

    // å…³æ‰å®ƒçš„å¹³æ»‘åŠ¨ç”»/è‡ªåŠ¨æ’å€¼ã€‚æˆ‘ä»¬è¦çº¯æ‰‹æ„Ÿï¼Œä¸è¦æ™ºèƒ½æ‘‡å¤´
    controls.enableAnimations = false;

    // æŠŠé˜»å°¼è®¾æˆæ¯”è¾ƒæ¸©çš„å€¼ï¼Œè®©æ‹–åŠ¨ä¸è‡³äºå¤ªè‚‰ï¼Œä¹Ÿä¸ä¼šé£
    controls.dampingFactor = 0.1;

    // ä¸éœ€è¦é‚£ç§å†…ç½®çš„å¯è§†åŒ–å°åæ ‡è½´gizmoï¼ˆå¦‚æœä½ åŸæœ¬æœ‰ setGizmosVisibleï¼‰
    if (typeof controls.setGizmosVisible === 'function') {
        controls.setGizmosVisible(false);
    }

    // é»˜è®¤å…è®¸è‡ªç”±æ—‹è½¬ã€ç¼©æ”¾ã€å¹³ç§»
    controls.enablePan      = true;
    controls.enableZoom     = true;
    controls.enableRotate   = true;

    // éå¸¸é‡è¦ï¼šå…è®¸å®Œå…¨è‡ªç”±ç¿»è½¬ï¼ŒåŒ…æ‹¬ roll
    // éƒ¨åˆ† ArcballControls ç‰ˆæœ¬æœ‰è¿™äº›é™åˆ¶æ ‡å¿—ï¼Œæ¯”å¦‚:
    // controls.enablePan = true;       // ä½ å·²ç»æœ‰
    // controls.enableRotate = true;    // ä½ å·²ç»æœ‰
    // controls.useAltKeys = false;     // å¦‚æœä½ çš„å®ç°æœ‰å¥‡æ€ªçš„è¾…åŠ©é”®æ‰å…è®¸æ—‹è½¬ï¼Œå¯ä»¥å…³æ‰
    // è¿™é‡Œæˆ‘ä»¬ä¸å¼ºè¡Œçº¦æŸâ€œä¸Šæ–¹å‘â€ï¼ŒArcballControls ä¼šå…è®¸ä»»æ„å››å…ƒæ•°æ—‹è½¬ï¼Œè¿™å°±æ˜¯è¿ç»­ç¿»è½¬

    controls.update();
}
reinitControls();

// controls.enableDamping = true; controls.dampingFactor = 0.08;
// controls.enableRotate = true;
// controls.enableZoom = true;
// controls.enablePan = true;
// controls.screenSpacePanning = true;
// controls.autoRotate = false;       // é»˜è®¤å…³é—­
// controls.autoRotateSpeed = 1.2;    // æƒ³è¦çš„æ—¶å€™æŠŠ autoRotate è®¾ä¸º true å³å¯

// controls.minAzimuthAngle = -Infinity;
// controls.maxAzimuthAngle =  Infinity;
// controls.minPolarAngle   =  0.0;       
// controls.maxPolarAngle   =  Math.PI;

const SNAP_NEAR = 0.03;   // æ¥è¿‘é˜ˆå€¼ï¼ˆå¼§åº¦ï¼‰ï¼Œè°ƒå¤§æ›´å®¹æ˜“å¸é™„
const sTmp = new THREE.Spherical();
const vTmp = new THREE.Vector3();

const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.9); scene.add(hemi);
// ç°æœ‰ hemi + dir ä¿ç•™ï¼Œå†åŠ ä¸€ç›æ·¡ç¯å¢ƒå…‰æŠ¬åº•
const amb = new THREE.AmbientLight(0xffffff, 0.55);
scene.add(amb);

const dir  = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(5,8,5); dir.castShadow = true; scene.add(dir);
const axes = new THREE.AxesHelper(0.1); axes.visible = true; scene.add(axes);

// --------- çŠ¶æ€ä¸å·¥å…· ---------
const registry = new Map(); let nextId = 1;
const stlLoader = new STLLoader();

function unionVisibleBox(){ const box=new THREE.Box3(); let has=false; registry.forEach(e=>{ if(!e.meshGroup.visible) return; const b=new THREE.Box3().setFromObject(e.meshGroup); if(!b.isEmpty()){ has=true; if(box.isEmpty()) box.copy(b); else box.union(b);} }); return {box,has}; }

function fitOrthoToVisible(margin = 1.2) {
    const {box,has} = unionVisibleBox();
    if(!has){
        const { w, h } = getCanvasSize();
        const aspect = w / h;
        const half = 1;
        camera.left   = -half * aspect;
        camera.right  =  half * aspect;
        camera.top    =  half;
        camera.bottom = -half;
        camera.updateProjectionMatrix();
        return;
    }

    // æ¨¡å‹åŒ…å›´ç›’å°ºå¯¸
    const size   = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);

    // half æ˜¯æˆ‘ä»¬å¸Œæœ›æ­£äº¤ç›¸æœºåœ¨â€œç«–å‘â€æ–¹å‘ä¸Šèƒ½çœ‹åˆ°çš„åŠè¾¹é•¿åº¦
    const half = (maxDim * margin) / 2;

    // ç”¨çœŸå®canvasæ¯”ä¾‹ï¼Œè€Œä¸æ˜¯windowçš„å‡å®šæ¯”ä¾‹
    const { w, h } = getCanvasSize();
    const aspect = w / h;

    camera.left   = -half * aspect;
    camera.right  =  half * aspect;
    camera.top    =  half;
    camera.bottom = -half;
    camera.updateProjectionMatrix();
}

// function snapView(kind){ const {box,has}=unionVisibleBox(); const center=has?box.getCenter(new THREE.Vector3()):new THREE.Vector3(); const size=has?box.getSize(new THREE.Vector3()):new THREE.Vector3(1,1,1); const maxDim=Math.max(size.x,size.y,size.z); const dist=maxDim*2.0; const dirs={front:new THREE.Vector3(0,0,1),back:new THREE.Vector3(0,0,-1),left:new THREE.Vector3(-1,0,0),right:new THREE.Vector3(1,0,0),top:new THREE.Vector3(0,1,0),bottom:new THREE.Vector3(0,-1,0),iso:new THREE.Vector3(1,1,1).normalize()}; const dirv=dirs[kind]||dirs.iso; camera.position.copy(center).addScaledVector(dirv,dist); camera.up.set(0,1,0); controls.target.copy(center); fitOrthoToVisible(1.1); console.log('[fit] after ', camera.position.x.toFixed(3), camera.position.y.toFixed(3), camera.position.z.toFixed(3));}

function getSceneFitInfo() {
    const { box, has } = unionVisibleBox();

    if (!has || box.isEmpty()) {
        const fallbackCenter = new THREE.Vector3(0, 0, 0);
        const fallbackDist   = 2.0;
        return {
            center: fallbackCenter,
            dist: fallbackDist
        };
    }

    const center = box.getCenter(new THREE.Vector3());
    const size   = box.getSize(new THREE.Vector3());

    const radius = Math.max(size.x, size.y, size.z) * 0.5;
    const dist   = radius * 2.0;

    return { center, dist };
}

function syncControlsToCameraAndCenter(centerVec3) {
    // centerVec3: æˆ‘ä»¬è®¤å®šçš„â€œæ—‹è½¬ä¸­å¿ƒâ€ï¼Œä¹Ÿå°±æ˜¯å½“å‰ç‰™æ¨¡çš„åŒ…å›´ç›’ä¸­å¿ƒ
    // ä½œç”¨ï¼šæŠŠ ArcballControls çš„å†…éƒ¨çŠ¶æ€é‡ç½®æˆ
    // â€œç°åœ¨cameraå’Œè¿™ä¸ªcenteræ˜¯ä¸€å¯¹æ–°çš„èµ·ç‚¹ï¼Œä¸è¦å†æ²¿æ—§è½´å¼¹å›â€ã€‚

    // ä¿å®ˆï¼šå¦‚æœæ²¡ç»™ï¼Œå°±è‡ªåŠ¨ç®—
    let pivot = centerVec3;
    if (!pivot) {
        const { center } = getSceneFitInfo();
        pivot = center;
    }

    // ä¿è¯æˆ‘ä»¬å…³é—­è‡ªåŠ¨åŠ¨ç”»
    controls.enableAnimations = false;
    controls.dampingFactor    = 0.1;

    // æ–¹æ¡ˆAï¼šæ–°ç‰ˆ ArcballControlsï¼Œå¸¦ setLookAt()
    if (typeof controls.setLookAt === 'function') {
        // ç”¨ camera çš„å½“å‰ä½ç½®å½“ eye
        const eyeX = camera.position.x;
        const eyeY = camera.position.y;
        const eyeZ = camera.position.z;

        controls.setLookAt(
            eyeX, eyeY, eyeZ,
            pivot.x, pivot.y, pivot.z,
            false // ä¸è¦è¿‡æ¸¡åŠ¨ç”»
        );
    } else {
        // æ–¹æ¡ˆBï¼šæ—§ç‰ˆ ArcballControls
        if (controls.target) {
            controls.target.copy(pivot);
        }
        // è®©æ§åˆ¶å™¨å†…éƒ¨æŠŠå®ƒå½“ä½œæ–°çš„åŸºå‡†
        controls.update();
    }

    // å†ä¿é™©ä¸€æ¬¡ï¼Œä¿æŒâ€œä¸è¦è‡ªå·±å†è½¬å›æ¥â€
    controls.enableAnimations = false;
    controls.dampingFactor    = 0.1;
    controls.update();
}

function snapByDirection(dir /* THREE.Vector3, å•ä½æ–¹å‘ï¼Œæ¯”å¦‚ (0,1,0) ç­‰ */) {
    const { center, dist } = getSceneFitInfo();

    // eye = center + dir * dist
    const eye = new THREE.Vector3()
        .copy(center)
        .addScaledVector(dir, dist);

    // ç›¸æœºæ”¾åˆ°æŒ‡å®šè§†è§’
    camera.position.copy(eye);

    // ä¸ºäº†è®©é¡¶è§† / åº•è§†ä¸å€’å¤´ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰æ–¹å‘è°ƒä¸€ä¸‹ up
    if (Math.abs(dir.y) > 0.9) {
        camera.up.set(0, 0, 1);
    } else {
        camera.up.set(0, 1, 0);
    }

    camera.lookAt(center);
    camera.updateMatrixWorld(true);

    // æ›´æ–°æ­£äº¤è§†ä½“ï¼Œä¿è¯è§†é‡é‡Œåˆšå¥½è£…ä¸‹ç‰™æ¨¡
    fitOrthoToVisible(1.1);

    // å…³é”®ï¼šæŠŠè¿™ä¸ªæ–°å§¿æ€å‘ŠçŸ¥ ArcballControlsï¼Œ
    // è®©å®ƒæŠŠè¿™å§¿æ€å½“æˆâ€œåˆå§‹çŠ¶æ€â€ï¼Œåç»­æ‹–åŠ¨å°±å›´ç»• center è‡ªç”±å››å…ƒæ•°æ—‹è½¬ï¼Œ
    // è€Œä¸æ˜¯ç»•å®ƒæ—§çš„é‚£æ¡å†å²è½´ã€‚
    syncControlsToCameraAndCenter(center);

    /*
	console.log('[snapByDirection] jumped view:', {
        eye: eye.toArray().map(v => v.toFixed(3)),
        center: center.toArray().map(v => v.toFixed(3)),
        dist: dist.toFixed(3),
        dir: dir.toArray().map(v => v.toFixed(3)),
        dampingFactor: controls.dampingFactor,
        enableAnimations: controls.enableAnimations
    });
	*/
}


function initViewAfterLoad() {
    const { center, dist } = getSceneFitInfo();

    // åˆå§‹å°±ç»™ä¸€ä¸ªèˆ’æœçš„ç­‰è½´æµ‹æ–¹å‘ï¼Œæ¯”å¦‚ (1,1,1)
    const dir = new THREE.Vector3(1, 1, 1).normalize();
    const eye = new THREE.Vector3().copy(center).addScaledVector(dir, dist);

    // ç›¸æœºæ”¾åˆ° eyeï¼Œçœ‹å‘ center
    camera.position.copy(eye);
    camera.up.set(0, 1, 0);
    camera.lookAt(center);
    camera.updateMatrixWorld(true);

    // æŠŠæ­£äº¤ç›¸æœºçš„æŠ•å½±ç›’å­é€‚é…ä¸€ä¸‹
    fitOrthoToVisible(1.15);

    // æœ€é‡è¦çš„ä¸€æ­¥ï¼šè®© ArcballControls æŠŠâ€œç°åœ¨è¿™ä¸ª eyeâ†’centerâ€å½“ä½œæ–°çš„åŸºå‡†ï¼Œ
    // ä¸è¦è®°ä½ä¹‹å‰é‚£ä¸ªä¹±ä¸ƒå…«ç³Ÿçš„çƒå¿ƒ/åŠå¾„ã€‚
    syncControlsToCameraAndCenter(center);
}

function snapView(kind){
  const dirs={
    front:new THREE.Vector3(0,0,1),
    back:new THREE.Vector3(0,0,-1),
    left:new THREE.Vector3(-1,0,0),
    right:new THREE.Vector3(1,0,0),
    top:new THREE.Vector3(0,1,0),
    bottom:new THREE.Vector3(0,-1,0),
    iso:new THREE.Vector3(1,1,1).normalize()
  };
  const dirv=dirs[kind]||dirs.iso;
  snapByDirection(dirv);
}


function createMaterial(kind, color='#cccccc', rough=0.45, metal=0.0, opacity=1.0){ const c=new THREE.Color(color); const common={ transparent:opacity<1, opacity, depthTest:true, depthWrite:opacity>=1, side:THREE.DoubleSide }; switch(kind){ case 'Phong': return new THREE.MeshPhongMaterial({ color:c, shininess:30, specular:0x222222, ...common }); case 'Toon': return new THREE.MeshToonMaterial({ color:c, ...common }); case 'Basic': return new THREE.MeshBasicMaterial({ color:c, ...common }); case 'Wireframe': return new THREE.MeshBasicMaterial({ color:c, wireframe:true, ...common }); case 'Physical': return new THREE.MeshPhysicalMaterial({ color:c, roughness:rough, metalness:metal, transmission:1-opacity, ior:1.5, clearcoat:0.2, ...common }); case 'Matcap': { const tex=new THREE.TextureLoader().load('./assets/matcap.jpg'); return new THREE.MeshMatcapMaterial({ matcap:tex, color:c, ...common }); } case 'Outline': return new THREE.MeshStandardMaterial({ color:c, roughness:rough, metalness:metal, ...common }); default: return new THREE.MeshStandardMaterial({ color:c, roughness:rough, metalness:metal, envMapIntensity:1.0, ...common }); } }
function ensureOutlineShell(group, geometry, color){ let outline=null; group.children.forEach(ch=>{ if(ch.isMesh && ch.material && ch.material.side===THREE.BackSide) outline=ch; }); if(!outline){ const edgeColor=(color? new THREE.Color(color).multiplyScalar(0.2): new THREE.Color(0x000000)); outline=new THREE.Mesh(geometry.clone(), new THREE.MeshBasicMaterial({ color:edgeColor, side:THREE.BackSide, transparent:false, opacity:1 })); outline.name='__outline__'; outline.scale.multiplyScalar(1.01); group.add(outline); } }

function removeOutlineShell(group){ for(let i=group.children.length-1;i>=0;i--){ const ch=group.children[i]; if(ch.isMesh && ch.material && ch.material.side===THREE.BackSide && ch.name==='__outline__'){ ch.geometry.dispose(); ch.material.dispose(); group.remove(ch);} } }

// function applyStyleToGroup(group, style, color, rough, metal, opacity){ group.traverse(o=>{ if(o.isMesh && !(o.material && o.material.side===THREE.BackSide)){ const mat=createMaterial(style==='Outline'?'Outline':style, color, rough, metal, opacity); if(o.material) o.material.dispose(); o.material=mat; }}); if(style==='Outline'){ const inner=group.children.find(ch=>ch.isMesh && !(ch.material && ch.material.side===THREE.BackSide)); if(inner) ensureOutlineShell(group, inner.geometry, color); } else removeOutlineShell(group); }

/*
function makeFaceLabelTexture(label) {
    // ç”¨ <canvas> åŠ¨æ€ç”»æ–‡å­—ï¼Œè½¬æˆçº¹ç†
    const size = 256;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    // èƒŒæ™¯
    ctx.fillStyle = '#222'; // æ·±è‰²åº•ï¼Œåˆ«å¤ªèŠ±
    ctx.fillRect(0, 0, size, size);

    // è¾¹æ¡†
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 8;
    ctx.strokeRect(16, 16, size - 32, size - 32);

    // æ–‡å­—
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 50px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, size / 2, size / 2);

    const tex = new THREE.CanvasTexture(canvas);
    tex.magFilter = THREE.LinearFilter;
    tex.minFilter = THREE.LinearMipmapLinearFilter;
    return tex;
}
*/

function makeFaceLabelTexture(label) {
    const size = 256;
    const r = size / 2;

    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    // ===== èƒŒæ™¯ï¼šåšä¸€ä¸ªå¾„å‘æ¸å˜ï¼Œè®©ä¸­é—´å¾®äº®ã€è¾¹ç¼˜å¾®æš—ï¼Œåƒä¸€å—å¾®å¾®æ‰“å…‰çš„å¡‘æ–™/äºšå…‹åŠ›é¢ =====
    const gradBg = ctx.createRadialGradient(
        r, r, r * 0.2,   // å†…åœˆä¸­å¿ƒï¼ŒåŠå¾„å°
        r, r, r          // å¤–åœˆä¸­å¿ƒï¼ŒåŠå¾„å¤§
    );
    gradBg.addColorStop(0.0, '#2f2f32'); // ä¸­å¿ƒç¨äº®ä¸€ç‚¹çš„æ·±ç°
    gradBg.addColorStop(1.0, '#1a1a1d'); // è¾¹ç¼˜æ›´æš—ä¸€ç‚¹ï¼Œæ”¶ä½

    ctx.fillStyle = gradBg;
    ctx.fillRect(0, 0, size, size);

    // ===== è¾¹æ¡†ï¼šä½¿ç”¨åœ†è§’çŸ©å½¢ + è½»å¾®çš„åŒå±‚æè¾¹ï¼Œæ˜¾å¾—æ›´åƒUIç»„ä»¶è€Œä¸æ˜¯debugæ¡† =====
    const inset = 20;
    const radius = 28;

    // å…ˆç”»åŠé€æ˜å¤–é«˜å…‰æè¾¹ï¼ˆåäº®ï¼‰
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    roundedRect(ctx, inset, inset, size - inset*2, size - inset*2, radius);
    ctx.stroke();

    // å†ç”»ä¸€å±‚å†…æè¾¹ï¼ˆåæš—ï¼‰ï¼Œæ¨¡æ‹Ÿåšåº¦
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    roundedRect(ctx, inset+2, inset+2, size - (inset+2)*2, size - (inset+2)*2, radius-8);
    ctx.stroke();

    // ===== æ–‡æœ¬ï¼šåŠç²—ä½“ + é—´è· + è½»å¾®å‘å…‰ï¼Œè®©å­—æœ‰æ‚¬æµ®æ„Ÿ =====
    // å­—ä½“
    ctx.font = '600 38px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // å‘å…‰ / å¤–æè¾¹
    ctx.fillStyle = '#ffffff';
    ctx.shadowColor = 'rgba(0,0,0,0.8)';
    ctx.shadowBlur = 12;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 2;

    // ä¸ºäº†æ›´â€œé¢æ¿åŒ–â€ï¼Œå­—æ¯ç¨å¾®æ‹‰å¼€ä¸€ç‚¹é—´è·ï¼ˆCanvasæ²¡ç›´æ¥çš„ letter-spacingï¼Œæ‰€ä»¥æ‰‹åŠ¨ç”»ï¼‰
    drawSpacedText(ctx, label.toUpperCase(), r, r, 8);

    // ç”Ÿæˆçº¹ç†
    const tex = new THREE.CanvasTexture(canvas);
    tex.magFilter = THREE.LinearFilter;
    tex.minFilter = THREE.LinearMipmapLinearFilter;
    return tex;

    // === å†…éƒ¨å°å‡½æ•°ï¼šç”»åœ†è§’çŸ©å½¢ ===
    function roundedRect(ctx, x, y, w, h, rad) {
        const r2 = Math.min(rad, w * 0.5, h * 0.5);
        ctx.beginPath();
        ctx.moveTo(x + r2, y);
        ctx.lineTo(x + w - r2, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r2);
        ctx.lineTo(x + w, y + h - r2);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r2, y + h);
        ctx.lineTo(x + r2, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r2);
        ctx.lineTo(x, y + r2);
        ctx.quadraticCurveTo(x, y, x + r2, y);
        ctx.closePath();
    }

    // === å†…éƒ¨å°å‡½æ•°ï¼šæ‰‹åŠ¨å®ç°â€œå­—è·â€ ===
    function drawSpacedText(ctx, text, cx, cy, spacingPx) {
        // å…ˆæµ‹æ•´æ®µå®½åº¦
        const metrics = ctx.measureText(text);
        // è¿‘ä¼¼å­—å®½ï¼ˆæ³¨æ„è¿™ä¸ªæ˜¯ç®€åŒ–ï¼Œå¤Ÿç”¨äº†ï¼‰
        const avgCharWidth = metrics.width / text.length;

        // æˆ‘ä»¬è®¡ç®—æ•´æ®µé¢å¤–æ€»é—´è·
        const extraTotal = spacingPx * (text.length - 1);

        // æ•´ä½“å®½åº¦ = åŸæœ¬å®½åº¦ + é¢å¤–é—´è·
        const totalWidth = metrics.width + extraTotal;

        // ä»å·¦èµ·å§‹ç‚¹
        let x = cx - totalWidth / 2 + avgCharWidth / 2;

        for (let i = 0; i < text.length; i++) {
            const ch = text[i];
            ctx.fillText(ch, x, cy);
            x += avgCharWidth + spacingPx;
        }
    }
}

function createLabeledDice(size = 1.0) {
    const diceGroup = new THREE.Group();

    const half = size / 2;

    // æˆ‘ä»¬åš6ä¸ªé¢ï¼Œæ¯ä¸ªæ˜¯ä¸€ä¸ªå¹³é¢ + æ–‡å­—æè´¨
    // æ¯ä¸ªé¢è¿˜éœ€è¦ä¸€ä¸ªèƒŒæ¿ï¼ˆç«‹æ–¹ä½“å¤–å½¢ï¼‰ï¼Œä½ å¯ä»¥ä¿æŒä½ ç°åœ¨å·²æœ‰çš„ cube å‡ ä½•å½“å¤–å£³
    // è¿™é‡Œåªæ¼”ç¤ºæ ‡ç­¾å¹³é¢

    const faces = [
        { label: 'TOP', dir: new THREE.Vector3( 0,  0,  1), rot: [0,0,0] },
        { label: 'BOTTOM',  dir: new THREE.Vector3( 0,  0, -1), rot: [0,Math.PI,0] },
        { label: 'RIGHT',  dir: new THREE.Vector3( 1,  0,  0), rot: [0,Math.PI/2,0] },
        { label: 'LEFT', dir: new THREE.Vector3(-1,  0,  0), rot: [0,-Math.PI/2,0] },
        { label: 'BACK',   dir: new THREE.Vector3( 0,  1,  0), rot: [-Math.PI/2,0,0] },
        { label: 'FRONT',dir: new THREE.Vector3( 0, -1,  0), rot: [ Math.PI/2,0,0] },
    ];

    const planeGeom = new THREE.PlaneGeometry(size, size);

    faces.forEach(f => {
        const mat = new THREE.MeshBasicMaterial({
            map: makeFaceLabelTexture(f.label),
            transparent: false,
        });
        const plane = new THREE.Mesh(planeGeom, mat);

        // æŠŠå¹³é¢æ”¾åˆ°è¯¥æœå‘çš„å¤–ä¾§
        plane.position.copy(f.dir).multiplyScalar(half + 0.001); // 0.001: é˜²Zå†²çª
        plane.rotation.set(f.rot[0], f.rot[1], f.rot[2]);

        // ç»™äº¤äº’ / raycaster ç”¨çš„ä¿¡æ¯ï¼šè¿™ä¸ªé¢ä»£è¡¨å“ªä¸ªæ–¹å‘
        plane.userData.viewDir = f.dir.clone().normalize();

        diceGroup.add(plane);
    });

    // ä½ ä¹Ÿå¯ä»¥åœ¨ diceGroup é‡Œå†åŠ ä¸€ä¸ªåŠé€æ˜çš„å°ç«‹æ–¹ä½“å¤–å£³ï¼Œä¿æŒç°åœ¨çš„è§†è§‰
    const cubeGeom = new THREE.BoxGeometry(size, size, size);
    const cubeMat = new THREE.MeshBasicMaterial({
        wireframe: true,
        color: 0xffffff,
        transparent: true,
        opacity: 0.2
    });
    const wireCube = new THREE.Mesh(cubeGeom, cubeMat);
    diceGroup.add(wireCube);

    return diceGroup;
}


function applyStyleToGroup(group, style, color, rough, metal, opacity){
  group.traverse(o=>{
    if (o.isMesh && !(o.material && o.material.side === THREE.BackSide)) {
      const mat = createMaterial(style === 'Outline' ? 'Outline' : style, color, rough, metal, opacity);
      if (o.material) o.material.dispose();
      o.material = mat;

      // ç»™ä¸»ä½“æè´¨åŠ è½®å»“é«˜å…‰ï¼Œstrength/power å¯æŒ‰å£å‘³å¾®è°ƒ
      attachRimLighting(o.material, 0.65, 3.0);
    }
  });
  if (style === 'Outline') {
    const inner = group.children.find(ch => ch.isMesh && !(ch.material && ch.material.side === THREE.BackSide));
    if (inner) ensureOutlineShell(group, inner.geometry, color);
  } else removeOutlineShell(group);
}

// åŸºäºè§†è§’çš„è½®å»“é«˜å…‰ï¼šåœ¨è¾¹ç¼˜å¤„æŒ‰ pow(rim, power) æäº®
function attachRimLighting(mat, strength = 0.35, power = 2.0) {
  if (!mat || !mat.onBeforeCompile) return;
  mat.onBeforeCompile = (shader) => {
    shader.fragmentShader = shader.fragmentShader
      .replace('#include <output_fragment>', `
        // åŸºäºè§†çº¿ä¸æ³•çº¿å¤¹è§’çš„è½®å»“å¼ºåº¦
        float rim = 1.0 - saturate(dot(normalize(vNormal), normalize(vViewPosition)));
        vec3 rimCol = vec3(1.0) * pow(rim, ${power.toFixed(1)});
        // åŸç‰‡å…ƒé¢œè‰²åœ¨ gl_FragColor ä¸­ï¼Œå…ˆæ‰§è¡ŒåŸé€»è¾‘
        #include <output_fragment>
        // å†æŠŠè½®å»“å…‰æ··è¿›æ¥
        gl_FragColor.rgb = mix(gl_FragColor.rgb, gl_FragColor.rgb + rimCol, ${strength.toFixed(2)});
      `);
  };
  mat.needsUpdate = true;
}

function mountPartUI(id){ const e=registry.get(id); const parts=document.getElementById('parts'); const el=document.createElement('div'); el.className='part'; el.dataset.id=id; el.innerHTML=`
  <div><input type="checkbox" class="v" ${e.meshGroup.visible ? 'checked' : ''}></div>
  
  <div>
    <div class="container">
      <div class="name">${e.name} </div>
      <div class="color-container">
        <label>Colour</label>
        <input type="color" class="col" value="${e.params.color}">
      </div>
      <button class="fit">FIT</button>
    </div>
    <div class="line">
      <label>RenderStyle<select class="mat">
        <option ${e.params.style==='Standard'?'selected':''}>Standard</option>
        <option ${e.params.style==='Phong'?'selected':''}>Phong</option>
        <option ${e.params.style==='Wireframe'?'selected':''}>Wireframe</option>
        <option ${e.params.style==='Physical'?'selected':''}>Physical</option>
        <option ${e.params.style==='Outline'?'selected':''}>Outline</option>
      </select></label>
    </div>
    <div class="line">
      <label>T<input type="range" class="opacity" min="0" max="1" step="0.01" value="${e.params.opacity}"></label>
      <label>R<input type="range" class="rough"   min="0" max="1" step="0.01" value="${e.params.roughness}"></label>
      <label>M<input type="range" class="metal"   min="0" max="1" step="0.01" value="${e.params.metalness}"></label>
    </div>
  </div>`; parts.appendChild(el);
  const chk=el.querySelector('.v'); const sel=el.querySelector('.mat'); const col=el.querySelector('.col'); const rough=el.querySelector('.rough'); const metal=el.querySelector('.metal'); const opac=el.querySelector('.opacity'); const btnFit=el.querySelector('.fit');
  chk.addEventListener('change', ()=>{ e.meshGroup.visible=chk.checked; if(document.getElementById('autoFit').checked) fitOrthoToVisible(); });
  sel.addEventListener('change', ()=>{ e.params.style=sel.value; applyStyleToGroup(e.meshGroup, e.params.style, e.params.color, e.params.roughness, e.params.metalness, e.params.opacity); });
  col.addEventListener('input', ()=>{ e.params.color=col.value; e.meshGroup.traverse(o=>{ if(o.isMesh && !(o.material && o.material.side===THREE.BackSide)) o.material.color.set(e.params.color); }); const outline=e.meshGroup.children.find(ch=>ch.name==='__outline__'); if(outline) outline.material.color.copy(new THREE.Color(e.params.color).multiplyScalar(0.2)); });
  rough.addEventListener('input', ()=>{ e.params.roughness=parseFloat(rough.value); e.meshGroup.traverse(o=>{ if(o.isMesh && 'roughness' in o.material) o.material.roughness=e.params.roughness; }); });
  metal.addEventListener('input', ()=>{ e.params.metalness=parseFloat(metal.value); e.meshGroup.traverse(o=>{ if(o.isMesh && 'metalness' in o.material) o.material.metalness=e.params.metalness; }); });
  opac.addEventListener('input', ()=>{ e.params.opacity=parseFloat(opac.value); e.meshGroup.traverse(o=>{ if(o.isMesh && o.material && !(o.material.side===THREE.BackSide)){ o.material.transparent=e.params.opacity<1.0; o.material.opacity=e.params.opacity; o.material.depthWrite=e.params.opacity>=1.0; o.material.needsUpdate=true; }}); });
  btnFit.addEventListener('click', ()=>{ const b=new THREE.Box3().setFromObject(e.meshGroup); if(!b.isEmpty()){ const c=b.getCenter(new THREE.Vector3()); controls.target.copy(c); fitOrthoToVisible(1.05); }});
}

// --------- æŒ‰ manifest.json ä»å­æ–‡ä»¶å¤¹åŠ è½½ ---------
async function loadFromFolder(folder){
  const manifestUrl = `./assets/${folder}/manifest.json`;
  try{
    const res = await fetch(manifestUrl, {cache:'no-cache'});
    if(!res.ok) throw new Error(`manifest ${res.status}`);
    const cfg = await res.json();
    if(!cfg || !Array.isArray(cfg.files)) throw new Error('manifest æ ¼å¼é”™è¯¯');

    // æ¸…ç©ºç°æœ‰
    registry.forEach(e=>{ scene.remove(e.meshGroup); e.meshGroup.traverse(o=>{ if(o.geometry) o.geometry.dispose(); if(o.material){ if(Array.isArray(o.material)) o.material.forEach(m=>m.dispose()); else o.material.dispose(); } }); });
    registry.clear(); document.getElementById('parts').innerHTML='';

    for(const item of cfg.files){
      await loadOne({
        name: item.name || item.file,
        url: `./assets/${folder}/${item.file}`,
        color: item.color || '#cccccc',
        style: item.style || 'Standard',
        opacity: typeof item.opacity==='number' ? item.opacity : 1.0,
		visible: item.visible
      });
    }

    // åˆå§‹åŒ–é•œå¤´å§¿æ€+target+æ­£äº¤ç¼©æ”¾ï¼Œè®©ç¬¬ä¸€ä¸‹é¼ æ ‡æ‹–æ‹½å°±æ˜¯æ­£å¸¸ç»•ä¸­å¿ƒæ—‹è½¬
    initViewAfterLoad();
  }catch(err){
    console.error('åŠ è½½ manifest å¤±è´¥', err);
    // ä¸æ˜¾ç¤ºä»»ä½•æ¨¡å‹ï¼›å¯æŒ‰éœ€æç¤º
  }
}

// --------- åŠ è½½å•ä¸ªæ¨¡å‹ï¼ˆSTLæˆ–GLBï¼‰ ---------
// ç»Ÿä¸€åŠ è½½ä¸€ä¸ªâ€œæ¨¡å‹æ–‡ä»¶â€ï¼ˆæ”¯æŒ .stl / .glb / .gltfï¼‰
async function loadOne(def){
  const ext = def.url.split('.').pop().toLowerCase();

  // å…¬å…±ï¼šå»ºç»„ã€ç™»è®°ã€æŒ‚ UI çš„å°è£…
  function finalizeWithGroup(grp) {
    scene.add(grp);
	grp.visible = (def.visible !== false);  // ğŸ‘ˆ æ ¹æ® manifest.json ä¸­ visible å†³å®šåˆå§‹æ˜¾ç¤ºçŠ¶æ€
    const id = String(nextId++);
    const params = {
      style:     def.style   || 'Standard',
      color:     def.color   || '#ccc',
      roughness: 0.45,
      metalness: 0.0,
      opacity:   def.opacity ?? 1.0
    };
    registry.set(id, { name: def.name || def.url.split('/').pop(), meshGroup: grp, params });
    applyStyleToGroup(grp, params.style, params.color, params.roughness, params.metalness, params.opacity);
    mountPartUI(id);
  }

  return new Promise((resolve, reject)=>{
    if (ext === 'stl') {
      // â€”â€” STL è·¯å¾„ï¼ˆä¸ä½ å½“å‰ä¸€è‡´ï¼‰â€”â€”
      stlLoader.load(def.url, (geom)=>{
        geom.computeVertexNormals();
        const innerMat = createMaterial(def.style || 'Standard', def.color || '#ccc', 0.45, 0.0, def.opacity ?? 1.0);
        const mesh = new THREE.Mesh(geom, innerMat);
        mesh.castShadow = mesh.receiveShadow = true;

        const grp = new THREE.Group();
        grp.add(mesh);

        finalizeWithGroup(grp);
        resolve();
      }, undefined, (err)=>reject(err));

    } else if (ext === 'glb' || ext === 'gltf') {
      // â€”â€” GLB/GLTF è·¯å¾„ â€”â€”ï¼ˆå°† glTF çš„ scene ä½œä¸ºä¸€ä¸ªæ•´ä½“â€œéƒ¨ä»¶â€ï¼‰
      const gltfLoader = new GLTFLoader();

      // å¦‚æœä½ çš„ .glb ä½¿ç”¨äº† Draco å‹ç¼©ï¼Œå–æ¶ˆä¸‹ä¸€æ®µæ³¨é‡Šï¼Œå¹¶æŠŠè§£ç å™¨æ–‡ä»¶æ”¾åˆ° ./libs/draco/ ä¸‹
      // import { DRACOLoader } from './libs/DRACOLoader.js';
      // const draco = new DRACOLoader(); draco.setDecoderPath('./libs/draco/'); gltfLoader.setDRACOLoader(draco);

      gltfLoader.load(def.url, (gltf)=>{
        const root = gltf.scene || gltf.scenes[0];
        root.traverse(o=>{
          if (o.isMesh) {
            o.castShadow = o.receiveShadow = true;
            // ä¸ºäº†ä¸ STL çš„é£æ ¼æ§åˆ¶ä¿æŒä¸€è‡´ï¼Œè¿™é‡Œè¦†ç›–æˆç»Ÿä¸€æè´¨ï¼›
            // å¦‚è¦ä¿ç•™ GLB åŸæè´¨ï¼Œå¯åˆ æ‰ä¸‹ä¸€è¡Œï¼š
            // 1) æ²¡æœ‰æ³•çº¿å°±è¡¥
            const g = o.geometry;
            if (!g.attributes.normal) {
              g.computeVertexNormals();
            }
      
            // 2) å…ˆä¿ç•™ GLB åŸæè´¨ï¼ˆé€šå¸¸æ›´â€œäº®â€æ›´çœŸå®ï¼‰
            //    åªåšå®‰å…¨æ€§å¾®è°ƒï¼šåŒé¢ + ç¯å¢ƒåå°„å¼ºåº¦
            if (o.material && o.material.isMeshStandardMaterial) {
              o.material.side = THREE.DoubleSide;
              if (typeof o.material.envMapIntensity === 'number') {
                o.material.envMapIntensity = 1.0; // ä½ ä¹Ÿå¯ä»¥åšæˆ UI æ»‘æ¡
              }
              o.material.needsUpdate = true;
            }
      
            // 3) å¦‚æœä½ æ˜ç¡®æƒ³ç”¨ç»Ÿä¸€é£æ ¼ï¼Œæ‰è¦†ç›–ï¼ˆä¾‹å¦‚ manifest é‡Œå†™äº† forceStyleï¼‰
            if (def.forceStyle === true) {
              o.material = createMaterial(def.style || 'Standard',
                                          def.color || '#ccc',
                                          0.45, 0.0,
                                          def.opacity ?? 1.0);
            }
          }
        });

        const grp = new THREE.Group();
        grp.add(root);

        finalizeWithGroup(grp);
        resolve();
      }, undefined, (err)=>reject(err));

    } else {
      reject(new Error('ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: ' + ext));
    }
  });
}


// --------- äº¤äº’ ---------
document.getElementById('btnFit').onclick = ()=> fitOrthoToVisible();
document.getElementById('btnShot').onclick = ()=>{ const a=document.createElement('a'); a.download='snapshot.png'; a.href=renderer.domElement.toDataURL('image/png'); a.click(); };
document.getElementById('showAxes').onchange = e=> axes.visible = e.target.checked;
window.addEventListener('resize', ()=>{
resizeMainRenderer();
fitOrthoToVisible();
});
document.getElementById('lightIntensity').oninput = (e)=>{
  const val = parseFloat(e.target.value);
  hemi.intensity = val;
  dir.intensity = val * 1.2; // ç¨äº®ä¸€ç‚¹çš„ä¸»å…‰
};

// å¸®åŠ©å¼€å…³
const help = document.getElementById('help');
document.getElementById('helpBtn').onclick = ()=> help.style.display = 'flex';
document.getElementById('helpClose').onclick = ()=> help.style.display = 'none';
help.addEventListener('click', (e)=>{ if(e.target===help) help.style.display='none'; });

// å­æ–‡ä»¶å¤¹åŠ è½½
const folderInput = document.getElementById('folderKey');
document.getElementById('btnLoadFolder').onclick = ()=>{ const key=folderInput.value.trim(); if(key) loadFromFolder(key); };
folderInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ const key=folderInput.value.trim(); if(key) loadFromFolder(key); } });

// å›ºå®šè§†è§’æŒ‰é’®ï¼ˆä¿æŒä¹‹å‰åŠŸèƒ½ï¼Œå¯æŒ‰éœ€å¤–éœ²åœ¨ UIï¼‰
function addViewButtons(){
  const wrap = document.createElement('div'); wrap.className='row';
  wrap.innerHTML = '<div class="grid2">\
  <button data-v="front">å‰è§†</button>\
  <button data-v="back">åè§†</button>\
  </div><div class="grid2" style="margin-top:6px">\
  <button data-v="left">å·¦è§†</button>\
  <button data-v="right">å³è§†</button>\
  </div><div class="grid2" style="margin-top:6px">\
  <button data-v="top">é¡¶è§†</button>\
  <button data-v="iso">ç­‰è½´æµ‹</button></div>';
  document.getElementById('left').insertBefore(wrap, document.querySelector('.hr'));
  wrap.querySelectorAll('button[data-v]').forEach(b=> b.onclick = ()=> snapView(b.dataset.v));
}
// addViewButtons();

// ===== å³ä¸‹è§’è§†è§’éª°å­ï¼ˆå°åœºæ™¯ + ç‹¬ç«‹æ¸²æŸ“å™¨ï¼‰=====

// 1) å•ç‹¬çš„å° renderer å åœ¨å³ä¸‹è§’
const diceRenderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
diceRenderer.setPixelRatio(window.devicePixelRatio || 1);
diceRenderer.setSize(120, 120);
diceRenderer.domElement.id = 'diceCanvas';
document.body.appendChild(diceRenderer.domElement);

// 2) å°åœºæ™¯ä¸ç›¸æœº
const diceScene  = new THREE.Scene();
const diceCamera = new THREE.PerspectiveCamera(35, 1, 0.1, 10);
diceCamera.position.set(0, 0, 3);

// 3) ç¯å…‰
const diceLight1 = new THREE.DirectionalLight(0xffffff, 0.9);
diceLight1.position.set(3, 4, 5);
diceScene.add(diceLight1);
const diceLight2 = new THREE.AmbientLight(0xffffff, 0.5);
diceScene.add(diceLight2);

// 4) åˆ›å»ºå¸¦æ–‡å­—æ ‡ç­¾çš„å…­é¢éª°ï¼ˆè€Œä¸æ˜¯æ—§çš„14é¢å‡¸åŒ…ï¼‰
//    è¿™ä¸€å‡½æ•°ä½ å‰é¢å·²ç»å®šä¹‰äº†ï¼šcreateLabeledDice(size)
//    å®ƒä¼šè¿”å›ä¸€ä¸ª Groupï¼Œé‡Œé¢æ¯ä¸ªé¢æ˜¯å¹³é¢ + æ–‡å­—çº¹ç†ï¼Œä¸” plane.userData.viewDir = æœå‘å‘é‡
const diceGroup = createLabeledDice(1.0);
diceScene.add(diceGroup);

// è®©éª°å­æ•´ä½“æœ‰ä¸€ç‚¹ç¼©å°ï¼Œä¸è¦å¤ªå¤§é¡¶æ ¼
diceGroup.scale.set(0.7, 0.7, 0.7);

// 5) è®©éª°å­çš„æœå‘è·Ÿéšä¸»ç›¸æœº
function syncDiceOrientation(){
    // æ–¹æ¡ˆï¼šéª°å­æ˜¾ç¤ºçš„æ˜¯â€œä¸–ç•Œåæ ‡ç³»çš„æ–¹ä½â€ï¼Œé€šå¸¸æˆ‘ä»¬å¸Œæœ›å®ƒè¡¨ç°ä¸º
    // â€˜å¦‚æœæˆ‘ç°åœ¨æ˜¯çœ‹Frontï¼Œéª°å­çš„FRONTæœæˆ‘â€™
    // ä¹Ÿå°±æ˜¯ diceGroup çš„æ—‹è½¬ = ä¸»ç›¸æœºæ—‹è½¬çš„é€†
    diceGroup.quaternion.copy(camera.quaternion).invert();
}

// 6) ç‚¹å‡»æ‹¾å–ï¼šç‚¹åˆ°æŸä¸ªæ ‡æ³¨é¢ => ç›´æ¥æŠŠä¸»ç›¸æœºåˆ‡åˆ°é‚£ä¸ªæ–¹å‘
const diceRay = new THREE.Raycaster();
const diceMouse = new THREE.Vector2();

diceRenderer.domElement.addEventListener('pointerdown', (ev)=>{
    const rect = diceRenderer.domElement.getBoundingClientRect();
    const x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;

    diceMouse.set(x, y);
    diceRay.setFromCamera(diceMouse, diceCamera);

    // ç‚¹çš„æ˜¯ diceGroup é‡Œçš„å­å¹³é¢ï¼ˆå¸¦æ–‡å­—çš„é‚£å— planeï¼‰
    const hits = diceRay.intersectObjects(diceGroup.children, true);
    if (!hits.length) return;

    const hitObj = hits[0].object;
    const dir = hitObj.userData.viewDir;
    if (!dir) return;

    /*
	console.log('[dice] click label => dir =',
        [dir.x.toFixed(3), dir.y.toFixed(3), dir.z.toFixed(3)],
        'faceLabel=', hitObj.material && hitObj.material.map ? 'hasLabelTexture' : '');
    */

    // æŠŠè¿™ä¸ªæ–¹å‘ä¼ ç»™ snapByDirectionï¼Œç›´æ¥ç¬é—´åˆ‡ä¸»ç›¸æœºè§†è§’
    snapByDirection(dir.clone().normalize());
});

// 7) çª—å£ç¼©æ”¾æ—¶æ›´æ–°å³ä¸‹è§’ renderer / ç›¸æœº
function resizeDice(){
    const s = 120; // ä¸ CSS #diceCanvas çš„å®½é«˜åŒæ­¥
    diceRenderer.setSize(s, s);
    diceCamera.aspect = 1;
    diceCamera.updateProjectionMatrix();
}
window.addEventListener('resize', resizeDice);

// æ¸²æŸ“ä¸»åœºæ™¯ + å°éª°å­
(function loop(){
    // ä¸»åœºæ™¯
    controls.update();
    renderer.render(scene, camera);

    // å°éª°å­åŒæ­¥æœå‘åå†æ¸²æŸ“
    syncDiceOrientation();
    diceRenderer.render(diceScene, diceCamera);

    requestAnimationFrame(loop);
})();


</script>
</body>
</html>
